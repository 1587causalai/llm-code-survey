# 岛屿数量问题学习笔记

## 问题描述
给定一个由 '1'（陆地）和 '0'（水）组成的二维网格，计算网格中岛屿的数量。
- 岛屿总是被水包围
- 岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成
- 可以假设该网格的四条边均被水包围

## 初始疑惑点记录
1. 对岛屿定义的理解困惑：
   - 最初以为岛屿需要四周都是水才算
   - 实际上只要是相连的陆地就算一个岛屿
   - 关键是理解"相连"指的是上下左右四个方向

2. 搜索过程的疑问：
   - 最初担心会有重复扫描的问题
   - 后来明白通过标记已访问的方式可以避免重复

## 解题思路

### 方法一：深度优先搜索（DFS）
核心思想：
1. 遍历整个网格
2. 当找到一个陆地时，使用DFS把与之相连的所有陆地都标记为已访问
3. 每启动一次新的DFS，就说明发现了一个新岛屿

### DFS具体步骤
1. 从网格的左上角开始，按照从左到右、从上到下的顺序遍历
2. 当遇到一个'1'（陆地）时：
   - 计数器+1（找到新岛屿）
   - 使用DFS访问这个陆地的上下左右四个方向
   - 将访问过的陆地标记为已访问（改为'#'或其他标记）
3. 继续遍历，重复步骤2
4. 最终计数器的值就是岛屿的数量

## 代码实现
```python
def numIslands(grid):
    if not grid:
        return 0
    
    rows = len(grid)
    cols = len(grid[0])
    islands = 0
    
    def dfs(i, j):
        # 越界或者不是陆地，直接返回
        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != '1':
            return
        
        # 将当前陆地标记为已访问
        grid[i][j] = '#'
        
        # 访问上下左右四个相邻位置
        dfs(i-1, j)  # 上
        dfs(i+1, j)  # 下
        dfs(i, j-1)  # 左
        dfs(i, j+1)  # 右
    
    # 遍历整个网格
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                islands += 1  # 发现一个新岛屿
                dfs(i, j)    # 标记整个岛屿
    
    return islands
```

## 优化思考
1. 避免重复访问
   - 通过直接修改原数组来标记已访问的格子
   - 每个格子最多只会被访问一次
   - 时间复杂度为O(m×n)，其中m和n是网格的行数和列数

2. 空间效率
   - 不需要额外的访问数组
   - 直接在原数组上修改，节省空间

## 示例分析
```
输入网格：
1 1 0
1 1 0
0 1 0

处理过程：
1. 从(0,0)开始，发现第一个岛屿
2. DFS会标记(0,0), (0,1), (1,0), (1,1), (2,1)这些相连的陆地
3. 所有这些格子都属于同一个岛屿
4. 最终结果：1个岛屿
```

## 需要继续深入理解的点
1. DFS递归的具体执行过程
2. 如何使用其他搜索算法（如BFS）来解决这个问题
3. 在实际场景中的应用（例如：图像处理、地图分析等）

## 学习心得
1. 图的搜索算法很重要，需要多加练习
2. 可视化对理解算法有很大帮助
3. 通过标记已访问来避免重复处理是一个常用的优化技巧
4. 不要被问题表面的复杂性吓倒，把问题分解成小步骤会更容易理解

## 后续学习计划
1. 学习更多图论相关的基础知识
2. 练习其他类似的搜索问题
3. 尝试使用不同的方法（BFS、并查集等）解决同一个问题
4. 理解递归的工作原理