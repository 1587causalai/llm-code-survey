# 颜色分类算法解析

## 问题描述

给定一个包含红色、白色和蓝色共 n 个元素的数组 nums，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。

我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。

### 要求
- 必须原地排序（不能使用额外数组）
- 不能使用内置的排序函数
- 空间复杂度要求 O(1)

### 示例
```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

## 解法一：计数排序

### 思路
由于只有0、1、2三种数字，可以：
1. 统计每个数字出现的次数
2. 根据统计结果重写原数组

### 代码实现
```python
def sortColors(nums):
    # 统计0,1,2的个数
    count = [0] * 3
    for num in nums:
        count[num] += 1
    
    # 根据频率重写原数组
    index = 0
    for i in range(3):
        for j in range(count[i]):
            nums[index] = i
            index += 1
```

### 复杂度分析
- 时间复杂度：O(n)，需要遍历两次数组
- 空间复杂度：O(1)，只需要常数额外空间存储计数数组

### 优点
- 代码简洁易懂
- 实现直观
- 性能稳定

### 缺点
- 需要遍历数组两次

## 解法二：单指针法

### 思路
1. 使用一个指针p记录当前应该放置元素的位置
2. 第一次遍历将所有的0交换到数组前面
3. 第二次遍历将所有的1交换到0之后的位置

### 代码实现
```python
def sortColors(nums):
    p = 0  # 当前写入位置
    
    # 第一次遍历，把所有的0放到前面
    for j in range(len(nums)):
        if nums[j] == 0:
            nums[p], nums[j] = nums[j], nums[p]
            p += 1
    
    # 第二次遍历，把所有的1放到0的后面
    for j in range(p, len(nums)):
        if nums[j] == 1:
            nums[p], nums[j] = nums[j], nums[p]
            p += 1
```

### 执行过程示例
以输入数组 [2,0,2,1,1,0] 为例：

第一次遍历（处理0）：
1. p=0: [2,0,2,1,1,0] -> [0,2,2,1,1,2]  
2. p=1: [0,2,2,1,1,2] -> [0,0,2,1,1,2]
   
第二次遍历（处理1）：
1. p=2: [0,0,2,1,1,2] -> [0,0,1,2,1,2]
2. p=3: [0,0,1,2,1,2] -> [0,0,1,1,2,2]

最终结果：[0,0,1,1,2,2]

### 复杂度分析
- 时间复杂度：O(n)，需要遍历两次数组
- 空间复杂度：O(1)，只使用常数额外空间

### 优点
- 原地排序
- 不需要额外空间
- 实现了真正的分类过程

### 缺点
- 代码逻辑相对复杂
- 需要理解指针移动的过程

## 总结

两种解法各有优势：
1. 计数排序：代码简单直观，适合快速实现
2. 单指针法：展示了更巧妙的解题思路，体现了算法的技巧性

实际应用中，如果追求代码的可读性和可维护性，建议使用计数排序解法。如果在面试中，可以先说出简单的计数排序解法，再补充说明单指针的解法，展示自己的算法思维能力。