# Word Break 动态规划问题深入解析

## 问题描述

给定一个字符串 s 和一个字符串字典 wordDict，判断是否可以利用字典中的单词拼接出字符串 s。需要注意：
- 字典中的单词可以重复使用
- 不要求使用字典中的所有单词

## 解题思路分析

### 1. 为什么使用动态规划？

这个问题具有以下特点：
- 可以将大问题分解为小问题：判断整个字符串是否可拆分可以转化为判断子串是否可拆分
- 具有重叠子问题：同一个子串可能会被多次判断
- 具有最优子结构：如果一个串可以被拆分，那么一定存在一种有效的拆分方式

### 2. 动态规划关键要素

#### dp数组定义
```python
dp = [False for _ in range(len(s)+1)]
# dp[i] 表示字符串s的前i个字符是否可以被拆分成字典中的单词
```

关键点：
- 数组长度为 len(s)+1，比原字符串多1
- dp[0] 表示空串，初始化为 True
- dp[i] 表示 s[0:i] 这个子串是否可拆分

#### 状态转移方程
```python
if dp[j] and s[j:i] in wordDict:
    dp[i] = True
```

理解要点：
- j 是分割点，将 s[0:i] 分成两部分：s[0:j] 和 s[j:i]
- dp[j] 保证前半部分可以拆分
- s[j:i] in wordDict 保证后半部分是一个完整单词

## 常见误区分析

### 1. 错误的子串检查方式
```python
# 错误写法
if s[:len(word)] == word:
    # 处理逻辑
```

这种写法的问题：
- 只能检查字符串的开头部分
- 无法处理中间或结尾的单词
- 忽略了字符串可以从任意位置切分的可能性

### 2. dp数组长度设置
```python
# 错误写法
dp = [False for _ in s]  # 长度少1
```

正确做法：
- dp数组长度应该是 len(s)+1
- 需要考虑空串的情况
- dp[0] 需要初始化为 True

### 3. 状态转移的思维误区
- 不要试图一次性找到所有匹配的单词
- 应该通过遍历所有可能的分割点(j)来构建解决方案
- 利用已解决的子问题(dp[j])来解决更大的问题(dp[i])

## 完整代码实现

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)  # 注意长度
        dp[0] = True  # 初始化空串
        
        for i in range(1, n + 1):
            for j in range(i):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break
        
        return dp[n]
```

## 复杂度分析

- 时间复杂度：O(n²*k)，其中n是字符串长度，k是子串比较的时间
- 空间复杂度：O(n)，用于存储dp数组

## 总结与思考

1. 动态规划的关键是找到正确的状态定义和转移方程
2. 处理字符串问题时，要特别注意边界情况（如空串）
3. 子问题的定义要能够覆盖所有可能的情况
4. 在实现时要注意避免常见误区，如数组长度、子串检查等

这个问题看似简单，但实际包含了很多细节和陷阱。通过理解这些关键点和常见误区，我们能够更好地掌握动态规划的思维方式。