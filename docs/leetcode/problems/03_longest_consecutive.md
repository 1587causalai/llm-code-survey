# 最长连续序列

给定一个未排序的整数数组，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。比如输入 [100,4,200,1,3,2]，最长的连续序列是 [1,2,3,4]，所以输出 4。

要求算法的时间复杂度为 O(n)，这意味着我们不能先对数组排序（排序至少需要 O(nlogn)）。这就是这道题的难点所在：如何在不排序的情况下找到所有的连续序列？

我们可以用一个很巧妙的方法：用集合来存储所有数字，这样查找某个数字是否存在的时间就是 O(1)。然后我们只需要找到每个连续序列的起点，从起点开始向后查找。

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if nums == []:
            return 0

        nums = set(nums)  # 去掉重复非常关键
        res = {}  # key 是当前连续序列的起点的最大连续序列长度
        
        for x in nums:
            if x not in res and x-1 not in res:  # x-1 不在里面才能保证是起点
                res[x] = 1
                y = x
                while y + 1 in nums:
                    res[x] += 1 
                    y += 1
                    res[y] = 1  # 关键步骤，标记已经考虑过的数字
         
        return max(res.values())
```

这个解法用到了几个关键的技巧：
1. 用集合存储所有数字，这样查找任意数字的时间都是 O(1)
2. 只从连续序列的起点开始计数，怎么找起点？如果一个数是起点，那它前面的数（x-1）一定不存在
3. 用字典标记已经访问过的数字，避免重复计算。这一步非常关键，保证了每个数字最多被访问一次

举个详细的例子，输入 [100,4,200,1,3,2]：
1. 遍历到 100：前面的数 99 不存在，是起点，往后找到 100，长度为 1
2. 遍历到 4：前面的数 3 存在，不是起点，跳过
3. 遍历到 200：前面的数 199 不存在，是起点，往后找到 200，长度为 1
4. 遍历到 1：前面的数 0 不存在，是起点，往后找到 1,2,3,4，长度为 4
5. 遍历到 3：已经被标记过了，跳过
6. 遍历到 2：已经被标记过了，跳过

时间复杂度是 O(n)，虽然代码里有 while 循环，但因为每个数字最多被访问一次（通过字典标记保证），所以总的时间复杂度还是 O(n)。
空间复杂度是 O(n)，主要用于存储集合和字典。 