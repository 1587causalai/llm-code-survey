# 三数之和

这是一道非常经典的数组题目，它不仅考察了我们对数组的基本操作，更重要的是训练我们如何把复杂问题拆解成更简单的子问题。

## 🌟 题目描述

给定一个整数数组 nums，找出所有和为 0 且不重复的三元组 [nums[i], nums[j], nums[k]]。
注意：需要满足 i ≠ j, i ≠ k, j ≠ k。

示例：
```python
输入：nums = [-1, -1, 0, 2]
输出：[[-1, -1, 2]]
```

## 💡 解题思路

这道题的思路演进特别有意思，让我们一步步来看：

### 1️⃣ 初始思路：二分查找

最开始，我们可能会这样想：
- 用两个指针（start, end）指向数组两端
- 用二分查找寻找第三个数

```python
while start < end:
    target = -(nums[start] + nums[end])
    # 用二分查找寻找 target
```

但这个思路有几个明显的问题：
- 😕 难以处理重复元素
- 😕 不容易确定该移动哪个指针
- 😕 二分查找的范围容易与 start 和 end 重叠

### 2️⃣ 优化思路：固定 + 双指针

这时我们有了一个关键的洞察：如果固定一个数，问题就变成了熟悉的"两数之和"！

核心思路：
1. 先排序，这样相同的数字会相邻，便于去重
2. 固定第一个数，转化为两数之和问题
3. 用双指针法解决剩余的两数之和

### 3️⃣ 去重策略

这是本题最容易出错的地方，需要在两个地方去重：
- 固定第一个数时：跳过相同的数字
- 移动双指针时：找到一组解后，跳过相同的数字

让我们通过一个具体的例子来理解为什么要这样做：

假设排序后的数组是：`[-1, -1, 0, 1]`

#### 第一轮遍历 (i = 0)：
```
数组：[-1, -1, 0, 1]
       ↑   ↑     ↑
       i   left  right
```
- 固定第一个 `-1`
- 在剩余数组 `[-1, 0, 1]` 中寻找两数之和为 `1` 的组合

#### 第二轮遍历 (i = 1)：
```
数组：[-1, -1, 0, 1]
        ↑   ↑    ↑
        i   left right
```
- 这时 `nums[1]` 也是 `-1`，和 `nums[0]` 相同
- 如果继续查找，必然会得到重复的组合
- 所以我们直接跳过这一轮，避免重复计算

这就是为什么代码中有这样一行：
```python
if i > 0 and nums[i] == nums[i-1]:
    continue  # 跳过重复的起始数字
```

## 🔥 代码实现

```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    nums.sort()  # 先排序，便于去重
    res = []

    for i in range(len(nums)-2):
        # 跳过重复的第一个数
        if i > 0 and nums[i] == nums[i-1]:
            continue

        left, right = i + 1, len(nums) - 1
        
        while left < right:
            x, y, z = nums[i], nums[left], nums[right]
            if x + y + z == 0:
                res.append([x, y, z])
                left += 1
                right -= 1
            elif x + y + z < 0:
                left += 1
            else:
                right -= 1

    # 最后统一去重
    res = [tuple(x) for x in res]
    res = set(res)
    res = [list(x) for x in res]
    return res
```

## 🎯 复杂度分析

- 时间复杂度：O(n²)
  - 排序：O(nlogn)
  - 双指针遍历：O(n²)
- 空间复杂度：O(1) 或 O(n)，取决于排序算法的实现

## 🚀 技巧总结

1. **问题转化**：三数之和 → 一个固定值 + 两数之和
2. **排序的作用**：
   - 让相同元素相邻，便于去重
   - 利用有序性质优化查找
3. **双指针技巧**：根据和的大小决定移动方向
4. **去重时机**：在固定数字和找到解时都需要去重

## 🔗 相关题目

- [两数之和](./01_two_sum.md)：本题可以看作是两数之和的进阶版
- 四数之和：可以用类似的思路，多固定一个数

## 💎 举一反三

1. 如果题目改为"找出和为给定值 target 的三个数"，如何修改代码？
2. 如果数组中有大量重复元素，还有什么优化空间？
3. 在实际工作中，类似的"多数之和"问题如何处理？ 