# 动态规划解题笔记：最长递增子序列

## 问题描述

给定一个整数数组 nums，找到其中最长严格递增子序列的长度。

示例:
```
输入: nums = [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长递增子序列是 [2,3,7,101]，长度为 4。
```

## 解题思路的演进

### 1. 理解问题的关键点

首先要理解什么是"严格递增子序列":
- 子序列可以不连续
- 要求严格递增，即后面的数必须大于前面的数
- 需要找到最长的这样的序列

### 2. 动态规划的核心要素

#### 2.1 定义dp数组
这是解题的最关键一步，dp[i] 的定义需要非常明确：
- dp[i] 表示：以 nums[i] 结尾的最长递增子序列的长度
- 为什么要"以nums[i]结尾"？这个限制保证了我们能够逐步构建出所有可能的递增序列

#### 2.2 初始化
- dp 数组初始化为 1
- 因为每个单独的数字都可以构成长度为 1 的递增子序列
- 代码：`dp = [1 for _ in range(n)]`

#### 2.3 状态转移方程
对于每个位置 i，需要考虑它前面的所有位置 j：
- 如果 nums[i] > nums[j]，说明可以把 nums[i] 接在以 nums[j] 结尾的序列后面
- 此时可以更新 dp[i] = max(dp[j] + 1, dp[i])
- 需要取max是因为可能有多种方式可以到达位置i

### 3. 代码实现

```python
def lengthOfLIS(self, nums: List[int]) -> int:
    n = len(nums)
    if n == 1:
        return 1
        
    dp = [1 for _ in range(n)]
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[j] + 1, dp[i])
                
    return max(dp)
```

### 4. 解题过程中的关键注意点

1. **dp数组定义的重要性**
   - 清晰的定义让状态转移更容易理解
   - "以nums[i]结尾"这个条件很关键

2. **初始化的合理性**
   - dp[i] = 1 是合理的起始点
   - 因为每个数字本身就是长度为1的递增序列

3. **遍历顺序的考虑**
   - 外层循环遍历当前位置
   - 内层循环遍历之前的所有位置
   - 这个顺序保证了我们能够利用之前计算的结果

4. **最终结果的处理**
   - 最长递增子序列不一定以最后一个数结尾
   - 因此需要遍历整个dp数组找最大值
   - 使用 max(dp) 而不是直接返回 dp[-1]

## 举例理解

以数组 `[10,9,2,5,3,7,101,18]` 为例：

1. 初始时所有 dp[i] = 1
2. 当处理到 nums[3] = 5 时：
   - 看它前面的数字：10, 9, 2
   - 发现 5 > 2，所以可以接在 2 后面
   - dp[3] = max(dp[2] + 1, dp[3]) = 2

3. 最终dp数组可能是：[1,1,1,2,2,3,4,4]

## 学习心得

1. 动态规划题目最关键的是定义好dp数组的含义
2. 定义时加上限制条件（如"以xx结尾"）往往能帮助我们更好地推导状态转移
3. 在理解题目时，可以通过具体例子来验证思路的正确性